### TCP 高级特性

------

[TOC]

##### 01：滑动窗口协议（Sliding Window Protocol）

- TCP 协议的一种应用，用于**网络数据传输时的流量控制**技术，以避免拥塞的发生；
- 该协议允许发送方在**停止并等待确认前发送多个数据分组**；由于发送方不必每发一个分组（分片）就停下来等待确认，因此该协议可以加速数据的传输速度，提高网络吞吐量；底层是用TCP报文段中的**窗口大小字段**来控制；
- 因为 TCP 是全双工传输，因此通信的双方都拥有两个滑动窗口，一个发送窗口，一个接收窗口；
  - 接收窗口 >= 发送窗口

###### 发送窗口

- 接收方允许发送方一次能容纳的未确认的字节数，决定了发送方允许传送的字节数大小，当收到接收方新的ACK（确认号）时，确认字节已经被接受，窗口向前滑动；
- ![](https://github.com/likang315/Network/blob/master/01：计算机网络/photos/sliding-window.png?raw=true)

###### 发送端

1. 已发送已确认
   - 数据流中最早的字节已经发送且已确认；
2. **已发送但未收到确认**
   - 已发送但未得到确认的字节，发送方在未被确认之前，认为这些数据还没有被处理；
3. **允许发送但尚未发送**
   - **数据已经被加载到缓存中（窗口）**
4. 不允许发送
   - 数据属于未发送，同时接收端也不允许发送的，因为这些数据已经超出了发送端窗口范围；

###### 接收端

- 已接收已确认；
- **未接收允许接收（接收窗口）**
- 未接收且不允许接收
  - 由于ACK直接由TCP协议栈回复，默认无应用延迟，**不存在已接收未回复ACK**


##### 02：滑动窗口协议的应用

###### 停止-等待协议（1 bit 滑动窗口协议）

- **接受方的窗口和发送方的窗口大小都是1bit**，所以也叫 1比特滑动窗口协议。
- 缺点：发送方每次只能发送1bit，并且必须等待这个数据包的ACK，才能发送下一个，所以**效率太低**，一直需要等待；

###### 回退n步协议

- 发送方在发完一个数据帧后，不会停下来等待应答帧，而是连续发送若干个数据帧，即使在连续发送过程中收到了接收方发来的应答帧，也可以继续发送。且**发送方在每发送完一个数据帧时都要设置超时定时器**，但是如果在设置的超时时间内仍未收到确认帧，就要**重发相应的数据帧，回退了n步**；
- 缺点：一旦网路情况比较糟糕时，反而**重复发送很多已经发送失败的帧**，效果反而不如1bit协议；
  - 数据帧：数据链路层的传输单位；


###### 选择重传协议

- 当出现错误帧后，总是要重发该帧之后的所有帧，所以**接收端总会缓存所有收到的帧，当某个帧出现错误时，只会要求重传这一个帧**，只有当某个序号后的所有帧都正确收到后，才会一起提交给上层应用。
- 缺点：接受端需要**更多的缓存**；

##### 03：TCP 粘包问题

- 发送方发送的**若干包数据到达接收方时粘成了一个包**，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾；

###### 发送方原因

- TCP 默认使用 Nagle 算法（主要作用：减少网络中的小数据包数量）
- Nagle算法的工作原理
  - 当发送方有一个小数据包需要发送时，它并不立即发送该数据包，而是将该数据包放入缓冲区等待。
  - 发送方会继续收集数据，直到满足以下条件之一，一旦满足，将缓冲区中的数据合并成一个大数据块，然后发送。
    1. 缓冲区中的数据量达到一定阈值；
    2. 发送方收到前一个数据包的确认信息；

###### 接收方原因

- TCP接收到数据包时，并不会马上交到应用层进行处理，TCP将接收到的数据包保存在**接收缓存里**，然后应用程序主动从缓存读取收到的分组。
- 如果TCP接收数据包到缓存的速度**大于**应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个**首尾相接粘到一起的包**。

###### 解决方式

- **消息边界标记**：在数据包中**增加特定的标记来标识消息的结束**，接收方通过检测这些标记来分割消息。
- **固定长度消息**：发送方在发送消息时，将**每个消息固定为相同的长度**，接收方根据固定长度来划分消息，从而避免粘包问题。
- **消息长度标记**：在消息头部添加消息长度信息，接收方首先读取消息长度，然后根据消息长度来划分消息。

##### 04：TCP 拥塞机制

- 网络拥塞：**网络中的流量超过了网络链路或节点的处理能力**，导致网络性能下降甚至瘫痪，**是一个全局性的过程和流量控制不同，流量控制指点对点通信量的控制**；
- **发送方维持一个拥塞窗口(cwnd)的状态变量**，拥塞窗口的大小取决于网络的拥塞程度，且动态地变化，发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口；
- <img src="/Users/likang/Code/Git/Network/01：计算机网络/photos/拥塞机制.png" style="zoom:40%;" />

###### 拥塞避免算法

1. 在慢启动阶段，先发送 1byte 的数据，**探测一下网络的拥塞程度**，发送方**以指数级别增加其拥塞窗口**，逐渐测试网络容量；
   - 设置一个慢开始门限 (ssthresh) 状态变量
     - 当cwnd < ssthresh，执行慢启动算法；
     - 当cwnd = ssthresh，慢开始和拥塞避免算法任意；
     - 当cwnd > ssthresh，拥塞避免算法；

2. 在拥塞避免阶段，发送方**通过线性增加拥塞窗口**，以更稳健的方式增加发送速率。如果网络出现拥塞，TCP会使用拥塞避免算法降低发送速率。
   - **每经过一个往返时间 RTT 就把发送方的拥塞窗口cwnd 加 1，不是加倍**；

3. 无论是在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络拥塞，就把**慢开始门限设置为出现拥塞时的发送窗口大小的一半，然后把拥塞窗口重置为 1 **，执行慢启动算法；

###### 快重传&快恢复

- **快重传**
  - 当接收方**收到一个失序的报文时，不必等到超时重传计时器到期，而是可以立即重传对应的确认信息（ACK）**，以通知发送方重发丢失的报文段。
  - 一般来说，重传发生在超时之后，但是如果**发送端接收到3个以上的重复确认ACK报文**，就应该意识到，需要重新传递，这个机制不需要等到**重传定时器溢出**，所以叫做快重传；
- **快恢复**
  - 在快重传之后，TCP连接进入快恢复状态。在快恢复状态下，**TCP发送方会继续以拥塞避免算法的方式发送数据，但发送速率会减半**。此时 TCP 发送方期望接收到新的确认信息，以表示网络已经恢复。

- 快重传和快恢复目的：快速恢复丢失的数据包；



